---
title: "Rapport de laboratoire 5"
subtitle: "MTH8211"
author:
  - name: Ulrich Baron-Fournier
    email: ulrich.baron-fournier@polymtl.ca
    affiliation:
      - name: Polytechnique Montréal
format:
  pdf:
    keep-tex: false
    documentclass: article
    include-in-header:
      - text: |
            \usepackage{xspace}
            \usepackage[francais]{babel}
    geometry:
      - margin=1in
    papersize: letter
    colorlinks: true
    urlcolor: blue
engine: julia
---

```{julia}
#| output: false
using Pkg
Pkg.activate("labo5_env")
Pkg.add("Krylov")
Pkg.add("SuiteSparseMatrixCollection")
Pkg.add("MatrixMarket")

using LinearAlgebra
using MatrixMarket
using Krylov, SuiteSparseMatrixCollection, SparseArrays
using SparseArrays
using SuiteSparse.CHOLMOD 
```

# Contexte

Dans ce laboratoire, on demande de valider le théorème de Murphy, Golub et Wathen sur le préconditionneur idéal pour les matrices de point de selle.
On se réfèrera aux carnets Jupyter vus en laboratoire pour les extraits de code pertinents.

# Questions

Choisir une matrice $A$ rectangulaire dans la `SuiteSparseMatrixCollection` et former la matrice de point de selle $K$ ainsi qu'un membre de droite.
Implémenter le préconditionneur idéal basé sur le complément de Schur.
Résoudre le système préconditionné avec MINRES et valider que le solveur s'arrête en (environ) 3 itération.

```{julia}
ssmc = ssmc_db()
pb = ssmc_matrices(ssmc, "", "illc1033")
path = fetch_ssmc(pb, format="MM")
path_mtx = path[1]
A = MatrixMarket.mmread(joinpath(path_mtx, "illc1033.mtx"))
m, n = size(A)
b = ones(m)
K = [I A ;
     A' spzeros(n, n)]
rhs = [b ; zeros(n)];
```

```{julia}
struct Precondition
  m :: Int
  n :: Int
  LLt :: Factor{Float64}
end

function Precondition(A)
    m, n = size(A)
    LLt = cholesky(A' * A) 
    return Precondition(m, n, LLt)
end

function LinearAlgebra.ldiv!(y, Pinv::Precondition, b)
    m, n, LLt = Pinv.m, Pinv.n, Pinv.LLt
    y[1:m] = b[1:m]
    y[m+1:end] = LLt \ b[m+1:end] 
    return y
end
```

Résolution du problème sans préconditionneur:
```{julia}
res = Krylov.minres(K, rhs)
```

Résolution du problème avec préconditionneur:
```{julia}
Pinv = Precondition(A)
res = Krylov.minres(K, rhs, M = Pinv, ldiv=true)
```

On peut voir que le nombre d'itération passe de 926 à 2 comme prévu après l'application du préconditionneur idéal!